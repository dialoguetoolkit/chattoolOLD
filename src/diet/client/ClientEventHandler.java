package diet.client;

import java.awt.event.KeyEvent;
import java.util.Date;
import java.util.Vector;


import diet.task.mazegame.ClientMazeGameComms;
import diet.attribval.AttribVal;
import diet.client.ClientInterfaceEvents.ClientInterfaceEvent;
import diet.client.ClientInterfaceEvents.ClientInterfaceEventTracker;
import diet.client.JChatFrameMultipleWindowWithSendButtonWidthByHeight.JChatFrameMultipleWindowsWithSendButtonWidthByHeight;


import diet.client.JChatFrameRightMost.JChatFrameRightMostMultipleWindows;
import diet.message.Keypress;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.SwingUtilities;
import javax.swing.text.AttributeSet;

/**
 * This is the intermediary between low-level exchange of messages between client and server (handled by ConnectionToServer)
 * and higher-level UI events handled by the JChatFrame chat window. 
 * <p> It handles both events generated by the chat window and also commands received from the server
 * 
 * <p> Some of the methods are associated with particular user interfaces. In particular, the methods pre-fixed with WYSIWYG
 * are associated with the "what you see is what you get" / character-by-character interfaces.
 * 
 * @author user
 */
public class ClientEventHandler {

    private JChatFrame jcf;
    private ConnectionToServer cts;
    /**
     * This records for each turn all keypresses. It is reset whenever the participant presses Enter/Return/Send
     */
    private Vector keyspressedSinceLastTextEntry = new Vector();
    private Vector clientEventsSinceLastTextEntry = new Vector();
    
    long startOfTyping = new Date().getTime(); //If they start typing before the interface is fully set up, this value is used as the start time
    boolean startOfTypingHasBeenRecorded = false;
    public boolean participantIsEnteringControlCode;
   // public boolean currentTurnBeingConstructedHasBeenBlocked = false;
   
    
    
    public ClientInterfaceEventTracker ciet = new ClientInterfaceEventTracker(this);
    

    //private ClientSetupParameters
    public ClientEventHandler() {
        super();
        
        
        
    }

    /**
     * Associates this with ConnectionToServer which deals with low-level exchange of messages
     * @param cts
     */
    public void setConnectionToServer(ConnectionToServer cts) {
        this.cts = cts;
    }

    /**
     * Associates this with a Chat window interface 
     * @param jcf
     */
    public void setChatFrame(JChatFrame jcf) {
        this.jcf = jcf;
        
    }

    public JChatFrame getChatFrame(){
        return jcf;
    }
    
    /**
     * Appends text to the participant's chat window. Text usually contains
     * @param s
     * @param windowNumber
     */
    public  void appendWithCaretCheck(String msgFROMSERVERID, String prefix,  boolean showPrefix, String text, int windowNumber, Object style ) {
            String s ="";
            String t ="";
            //if(prefix==null)System.exit(-5);
            if(prefix!=null) s = s+ prefix;
            if(text!=null)t=t+text;
            jcf.appendWithCaretCheck(msgFROMSERVERID, s+": ", showPrefix,    t, windowNumber, style );
            
    }

    /**
     * Don't need to press a send button if participants press ENTER
     */
    public void sendButtonPressedDEPRECATED() {
        
          /*  String[] priorChatText = {"","",""};
            String text = jcf.getTextEnteredInField();
            text = text.replaceAll("\n", "");
           if(jcf instanceof JChatFrameMultipleWindowsWithSendButtonWidthByHeight){
                 jcf.appendWithCaretCheck("", cts.getUsername()+ ": ", true, text, jcf.getParticipantsOwnWindow(), "SELF");
     
            }
            
            cts.sendChatText(text, startOfTyping, false, keyspressedSinceLastTextEntry,priorChatText);
           
            jcf.clearTextEntryField(true);
            clearKeypressesAndClientEventsAfterSend();
           
        */
        
                

    }

    /**
     * Retrieves text from chat window's text-entry field, does preliminary removal of white space, appends it to the local
     * client's chat window, sends the text to {@link ConnectionToServer} in order to be sent to the server, clears the local
     * timing / and keypress information associated with the turn and then clears the text-entry field.
     */
    public void returnPressed() {
	//System.out.println("return pressed");
    
        //System.err.println("THE CONTENTS ARE:"+jcf.getContentsOfWindow(0));
        //System.err.println("---------------------------");
        
           // String[] priorChatText = {"","",""} ;
            
            String text = jcf.getTextEnteredInField();
            text = text.replaceAll("\\p{Cntrl}", "");
            if(jcf instanceof JChatFrameMultipleWindowsWithSendButtonWidthByHeight){
                 jcf.appendWithCaretCheck("", cts.getUsername()+ ": ", true, text, jcf.getParticipantsOwnWindow(), "SELF");
            }
            
             if(diet.debug.Debug.debugIO){
                            diet.debug.Debug.showDebug2("\nSENDING: "+keyspressedSinceLastTextEntry.size());
             }
            
            
            cts.sendChatText((text), startOfTyping, false, keyspressedSinceLastTextEntry,this.clientEventsSinceLastTextEntry);
            
            
            jcf.clearTextEntryField(true);
            clearKeypressesAndClientEventsAfterSend();
            
           
        
          
    }

    /**
     * Clears the information stored for the turn being constructed
     */
    public void clearKeypressesAndClientEventsAfterSend() {
        startOfTypingHasBeenRecorded = false;
        startOfTyping = -400000;
        keyspressedSinceLastTextEntry.removeAllElements();
        keyspressedSinceLastTextEntry = new Vector();
        
        this.clientEventsSinceLastTextEntry.removeAllElements();
        this.clientEventsSinceLastTextEntry = new Vector();
    }

    
    
    
    
    /**
     * Processes each keypress associated with the chat tool window.
     * In the current implementation, any key pressed while pressing 
     * and holding down the "Ctrl key" is treated as not being associated
     * with turn-construction and is instead relayed to the TaskController (e.g
     * ClientMazeGameComms if it exists).
     *
     * @param e
     */
    public void keyPressFilter(KeyEvent e) {
    
        try{ 
        if (cts.cteh != null && cts.cteh instanceof ClientMazeGameComms) {
            ((ClientMazeGameComms)cts.cteh).relayKeypressToMazeFrame(e);
        }
        
        int i = e.getKeyCode();
        if (i == 17) {
            this.participantIsEnteringControlCode = true;
            this.jcf.setEditable(false);
            
        }
        if (this.participantIsEnteringControlCode) {
            if (i == 37 || i == 38 || i == 39 || i == 40) {
                
            }
        } else if (!participantIsEnteringControlCode) {
            if (!startOfTypingHasBeenRecorded) {
                startOfTypingHasBeenRecorded = true;
                startOfTyping = new Date().getTime();
            }
          
           
            Keypress kp = new Keypress(i, new Date().getTime());
            keyspressedSinceLastTextEntry.addElement(kp);
            
            
             if(diet.debug.Debug.debugIO){
                            diet.debug.Debug.showDebug2("\nCLIENT: "+keyspressedSinceLastTextEntry.size());
             }
            
             cts.sendClientIsTyping(kp, this.jcf.getTextEnteredInField().replaceAll("\\p{Cntrl}", ""));
             //cts.sendClientIsTyping(kp, ".....");
        }
       }catch (Exception e2){
           cts.sendErrorMessage(e2);
       }

    }

    /**
     * Detects whether the key being released is the "Ctrl" key. If yes, the
     * control sequence being relayed to the TaskController (e.g. ClientMazeGameComms) is
     * terminated. 
     * @param e
     */
    public void keyReleaseFilter(KeyEvent e) {
      try{  
        if (cts.cteh != null && cts.cteh instanceof ClientMazeGameComms) {
            ((ClientMazeGameComms)cts.cteh).relayKeyReleaseFilterToMazeFrame(e);
        }
        
        if (e.getKeyCode() == 17) {
            participantIsEnteringControlCode = false;
            this.jcf.setEditable(true);
        //System.out.println("go"+e.getKeyCode());

        }
        if (e.getKeyCode() == 10 ) {
           //// returnPressed();   ///this is no longer called from this method.Instead it is called from the Document of the chatframe
        }
      }catch (Exception e2){
          cts.sendErrorMessage(e2);
      }
    }

    /**
     * Adds String to the WYSIWYG chat window at the specified position
     * @param windowNumber
     * @param replacementText
     * @param offset
     * @param length
     */
    public void wYSIWYGUpdateDocumentAppend(int wysiwygWindowNumber, String appendedText, AttributeSet as, String usernameOther) {
        jcf.wYSIWYGUpdateDocumentAppend(wysiwygWindowNumber, appendedText, as, usernameOther);
    }

    /**
     * Removes text from the chat window at the specified position/length
     * @param windowNumber
     * @param offset
     * @param length
     */
    public void wYSIWYGUpdateDocumentRemove(int windowNumber, int offset, int length) {
        jcf.wYSIWYGUpdateDocumentRemove(windowNumber, offset, length);
    }

    public void wYSIWYGDocumentHasChangedInsert(String textAtEndOfString, int offset, String contentsOfWindow, boolean controlPressed, long fadeOut) {
        try {
            //System.out.println("WYSIWYGCLEVENTHANDLER1");
            cts.sendWYSIWYGDocumentHasChangedInsert(textAtEndOfString, offset, contentsOfWindow, controlPressed, fadeOut);
            //cts.sendChatTextWYSIWYG(textAtEndOfString, offset, contentsOfWindow, controlPressed);
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            //EMUI.println(cts.getUsername(),"ERROR IN CLEVENTHANDLER");
        }
    //clearKeypresses();
    }

    /**
     * Invoked by the WYSIWYG interface when text is deleted at the specified offset/length
     * @param offset
     * @param length
     */
    public void wYSIWYGDocumentHasChangedRemove(int offset, int length, String textInTextEntryWindow) {
        try {
            String[] priorChatText = {"","",""};
            cts.sendWYSIWYGDocumentHasChangedRemove(offset, length, textInTextEntryWindow, priorChatText);
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            cts.sendErrorMessage(e);
        }
    }

    /**
     * Invoked by the WYSIWYG interface when text is inserted at the specified offset/length
     * @param text
     * @param offset
     * @param length
     */
    public void textEntryDocumentHasChangedInsert(String text, int offset, int length,String textInTextEntryWindow) {
        try {
         
            cts.sendWYSIWYGDocumentHasChangedInsert(text, offset, length, textInTextEntryWindow );
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            cts.sendErrorMessage(e);
        }
    }

    
  
    
    
    
    
   

    /**
     * Changes the position of the cursor and the selected text in the WYSIWYG chat window
     * @param windowNumber
     * @param startPos
     * @param finishPos
     */
    public void wWYSIWYGChangeCursorAndSelectionInWindow(int windowNumber, int startPos, int finishPos) {
        jcf.wYSIWYGChangeCursorAndSelection(windowNumber, startPos, finishPos);
    //System.out.println("RECEIVING SELECTION "+startPos+" "+finishPos);
    }

   

    
    

    

   
     
     
     
    
  
    
    public ConnectionToServer getCts() {
        return this.cts;
    }

    
    public void changeInterfaceProperties(String uniqueIDGeneratedByServer, int newInterfaceproperties, final Object value, final Object value2, final Object...values){
        
        
         if(newInterfaceproperties == (ClientInterfaceEventTracker.changeMazeWindow)){
                    try{
                       ((ClientMazeGameComms)     this.cts.cteh).displayMessageInWindow((String)value, (Long)value2);
                    }catch (Exception e){
                        e.printStackTrace();
                    }
                    return;
        }
        if(newInterfaceproperties ==(ClientInterfaceEventTracker.changeBorderOfMazeFrame)){
           ClientMazeGameComms cmgc = (ClientMazeGameComms)    this.cts.cteh;
           cmgc.changeBorderOfMazeFrame((int)value,(Color)value2);
        }
        
        if (newInterfaceproperties == (ClientInterfaceEventTracker.changetoCBYC_MultipleTrack)){      
          final ClientEventHandler thisceh = this;  
          SwingUtilities.invokeLater(new Runnable(){
              public void run(){
                  Dimension d = (Dimension)value;
                  long duration = (Long)value2;
                  int state = (int)values[0];
                  int numberOfWindows = (int)values[1];
                  
                  JChatFrameRightMostMultipleWindows jcfrmmw = new JChatFrameRightMostMultipleWindows(thisceh, d.width, d.height, duration, state, numberOfWindows);
                  jcf.setFocusable(false);
                  jcf.setVisible(false);
                  jcf=jcfrmmw ;      
              }
          });
        }
        else if(newInterfaceproperties==ClientInterfaceEventTracker.dodebugrobot){
                  DebugRobotNew dbrn= new DebugRobotNew();
                  dbrn.startDebug(value, value2);
        }
        
        
        else {
            jcf.changeInterfaceProperties(uniqueIDGeneratedByServer, newInterfaceproperties, value, value2);    
        }
        
        
        // System.exit(-444445);
    }
    
    
    
    /**
     * Closes down the client, freeing resources
     */
    public void closeDown() {
        try {
            jcf.setVisible(false);
            jcf.closeDown();
            jcf.dispose();
            this.jcf=null;
            cts = null;
            System.err.println("ClientEventHandler closing down");
        } catch (Exception e) {
            
        }
        System.exit(-111222);
        System.err.println("CLOSING DOWN THE CLIENT");
    }
    
    
    
    public void reportInterfaceEvent(String type, long clienttimeofdisplay,  AttribVal...values){    
        ClientInterfaceEvent ce = this.ciet.addClientEvent(type,clienttimeofdisplay, values);
        this.clientEventsSinceLastTextEntry.add(ce);
    }
    
    
    
    
    
    
   
    
}
