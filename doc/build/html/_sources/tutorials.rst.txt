.. highlight:: none

*********
Tutorials   
*********


From a programming perspective, there are, broadly speaking, seven different types of experiment: 

* Interventions that intercept a turn and insert additional text into the turn.
* Interventions that intercept a turn and remove text from the turn.
* Interventions that intercept and modify text from a participant's turn.
* Interventions that intercept turns and do not relay them to other participants (i.e. "shadowbanning").
* Interventions that intercept turns and spoof the origin of the turn - e.g. making a turn produced by participant A appear to be produced by participant B.
* Interventions that compose artificial turns that appear to a recipient as if they were produced by another participant.
* Interventions that modify the timing of participants' turns.
* Interventions that assign participants to different groups (e.g. to different subcommunities).
* Interventions that modify features of the chat interface (E.g. size, colour), etc.


Of course - some experiments might involve multiple types of intervention - e.g. manipulating the timing and apparent identity of participants' turns. 

Tutorial1 - Inserting, removing, substituting text in participants' turns
=========================================================================

This is a toy setup which randomly adds smiley emoticons to participants' turns - without participants realizing it! 

To keep this tutorial simple, this experiment assumes you will be running experiments with two participants. 


For this experiment we will use the Turn By Turn Interface. To use this interface in a new experiment you need to create a subclass of it.

Create a copy of ``diet.server.ConversationController.DyadicTurnByTurn_Tutorial1_InsertingRemovingSubstituting`` and call it ``DyadicTurnByTurn_Tutorial1_InsertingRemovingSubstituting``. You can do this automatically in netbeans by right-clicking ``Dyadic_TurnByTurnInterface``, selecting "Refactor" , then selecting "Copy" and entering "DyadicTurnByTurn_Tutorial1_InsertingRemovingSubstituting" as the new name. Make sure the destination package is diet.server.ConversationController.

Make sure that your ConversationController object has::

   public static boolean showcCONGUI(){
        return true;
   }

This will make sure that the ConversationController object is displayed in the GUI window of the server. Select "Run project" to start the server GUI. You should see the newly created conversationcontroller object in the GUI.

.. image:: ./tutorial1A.png

Press the "Auto login" button. This should run the intervention and start two clients. Confirm that participants can send each other text.
   

Now we can program the intervention. The ConversationController object has a whole set of methods for determining who sees what.

First, let's add a welcome message for the participants, and an instruction to start when both participants log in::

    public synchronized void participantJoinedConversation(final Participant p) {
        super.participantJoinedConversation(p);  //Keep this in your code - to assign participants to groups and ensure they see each other's typing notification.
		if(c.getNoOfParticipants()==1){
             c.sendInstructionToParticipant(p,"Hello! Please wait for the other participant to log in");
        }
        else if (c.getNoOfParticipants()==2){
             c.sendInstructionToMultipleParticipants(c.getParticipants().getAllParticipants(), "Please start!");
        }
             
    }
	

Inserting text in participants' turns.
--------------------------------------


To create the intervention that manipulates the text, customize the ``processChatText(...)`` method.  Before modifying it, the code looks like this.

.. code-block:: java
   :linenos:
   

   public synchronized void processChatText(Participant sender, MessageChatTextFromClient mct){    
          itnt.processTurnSentByClient(sender);
          c.relayTurnToPermittedParticipants(sender, mct);
   }

This code does two things. Line 2 takes care of the typing status messages:  This code sends instructions to all the participants other than ``sender``, instructing them to stop displaying the "participant X" is typing status message. Line 3 sends the message from the sender to all the other participants.

To create the intervention, the ConversationController needs to intercept the incoming turn and add an emoticon to it. Change ``processChatText(..)`` to

.. code-block:: java
   :linenos:
   
    Random r = new Random();
    public synchronized void processChatText(Participant sender, MessageChatTextFromClient mct){    
          itnt.processTurnSentByClient(sender);
          
          if(r.nextBoolean()){
               String turn = mct.getText() + " :)" ;
               Vector recipients = pp.getRecipients(sender);
               c.sendArtificialTurnFromApparentOriginToRecipients(sender, recipients, turn);
          }
          else{
               c.relayTurnToPermittedParticipants(sender, mct);     
          }      
    }


This code randomly chooses whether to perform the intervention or not.  Line 6 extracts the original turn from the ``MessageChatText`` message and uses it to construct the new message with a smiley emoticon ":)" appended to it. Line 7 retrieves the list of  participants who receive the turn (in this case it is only one participant). Line 8 sends the artificial turn. Line 8 is important because it does two things: (1) It sends the artificial message to the other participant(s) (2) It ensures that the correct information is saved in the output file "turns.txt. To illustrate this, consider the following table from "turns.txt" in the output folder:

.. image:: ./tutorial1Adata.png

This corresponds to a dialogue between two participants. The first participant has ID LLLL3 and username LLLL3. The second participant has ID RRRR4 and username RRRR4. They had the following dialogue:

1. **LLLL3:** Hello
2. **RRRR4:** Hi
3. **LLLL3:** How are you?
4. **RRRR4:** I am great
5. **LLLL3:** great
 
Where turns 1 and 4 were artificially modified by the server. 
Notice how, although the dialogue has 5 turns, there are 7 rows of data in the output. This is because whenever a turn is not relayed to all participants, the server automatically saves it as an  "intercepted turn" (see column D - Turntype, in the spreadsheet). Look at the first row of data in the spreadsheet. Notice how the intercepted turn has "server" as the sole recipient. Notice also how the modified turn is saved as an "artificial turn"(see column D - Turntype). This "artificialturn" is sent from the server (column E), but the ApparentSender (column G) is LLL3.


Important: When programming interventions it is important to distinguish between artificial turns and turns that are relayed. The reason is that. 



Removing text from participants' turns
--------------------------------------

Suppose that you want to write code that removes all unhappy emoticons ":(" from participants' turns. This can be done by adding one more line to the code from the previous example:

.. code-block:: java
   :linenos:
   
       public synchronized void processChatText(Participant sender, MessageChatTextFromClient mct){    
          itnt.processTurnSentByClient(sender);
          
          String turn = mct.getText();
          
          if(turn.contains(":(")) {
               turn = turn.replace(":(", "");
               Vector recipients = pp.getRecipients(sender);
               c.sendArtificialTurnFromApparentOriginToRecipients(sender, recipients, turn);
          }
          else{
                c.relayTurnToPermittedParticipants(sender, mct);  
          }          
    }
   
   












I